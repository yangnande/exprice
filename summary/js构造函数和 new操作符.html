<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>https://juejin.im/post/6894401976809816077?utm_source=gold_browser_extension</title>
</head>
<body>
    <p>1 构造器和操作符 "new"使用场景</p>
    <p>常规的 {...} 语法允许创建一个对象。但是我们经常需要创建许多类似的对象，例如多个用户或菜单项等</p>
    <p>2 构造函数用法</p>
    <p>在技术上是常规函数。不过有两个约定：</p>
    <p>它们的命名以大写字母开头。</p>
    <p>它们只能由 "new" 操作符来执行。</p>
    <p>3 new 操作符</p>
    <p>3.1 创建一个新的空对象并分配给 this。</p>
    <p>3.2 函数体执行。通常它会修改 this，为其添加新的属性。</p>
    <p>3.3 返回 this 的值。</p>
    <p>构造器的主要目的 —— 实现可重用的对象创建代码。</p>
    <p>注意：从技术上讲，任何函数都可以用作构造器。即：任何函数都可以通过 new 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 new 来运行。</p>
    <p>4 new function() { ... }</p>
    <p>使用目的：创建单个复杂对象,可以将它们封装在构造函数中</p>
    <p>5 new.target 属性来检查它是否被使用 new 进行调用了</p>
    <p>不带 "new"：undefined，带 "new"，等于该函数</p>
    <p>6 构造器的 return</p>
    <p>通常，构造器没有 return 语句。它们的任务是将所有必要的东西写入 this，并自动转换为结果。</p>
    <p>但是，如果这有一个 return 语句，那么规则就简单了:</p>
    <p>如果 return 返回的是一个对象，则返回这个对象，而不是 this。</p>
    <p>如果 return 返回的是一个原始类型，则忽略。</p>
    <p>换句话说，带有对象的 return 返回该对象，在所有其他情况下返回 this。</p>
    <p>7 构造器中的方法</p>
    <p>使用构造函数来创建对象会带来很大的灵活性。构造函数可能有一些参数，这些参数定义了如何构造对象以及要放入什么。</p>
    <p>当然，我们不仅可以将属性添加到 this 中，还可以添加方法。</p>
    <p>总结</p>
    <p>构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。</p>
    <p>构造函数只能使用 new 来调用。这样的调用意味着在开始时创建了空的 this，并在最后返回填充了值的 this。</p>
    <p>我们可以使用构造函数来创建多个类似的对象。</p>
    <p>JavaScript 为许多内置的对象提供了构造函数：比如日期 Date、集合 Set 以及其他我们计划学习的内容。</p>
    <script>
        // 2 构造函数用法
        // function User(name) {
        //    // this = {};（隐式创建）
        //   console.log(this) // User {}
        //   // 添加属性到 this
        //   this.name = name;
        //   this.isAdmin = false;
        //   // return this;（隐式返回）
        // }
        // let user = new User("Jack");
        // console.log(user); // user {name:Jack,isAdmin:false}
        // console.log(user.name); // Jack
        // console.log(user.isAdmin); // false
        // 4 new function() { ... }
        // let user2 = new function() {
        //   this.name = "John";
        //   this.isAdmin = false;
        //   // ……用于用户创建的其他代码
        //   // 也许是复杂的逻辑和语句
        //   // 局部变量等
        // };
        // console.log(user2);
        // 5 new.target 属性来检查它是否被使用 new 进行调用了
        // function User() {
        //   console.log(new.target);
        // }
        // 不带 "new"：
        // User(); // undefined
        // 带 "new"：
        // new User(); // function User { ... }
        // function User(name) {
        //   if (!new.target) { // 如果你没有通过 new 运行我
        //     return new User(name); // ……我会给你添加 new
        //   }
        //   this.name = name;
        // }

        // let john = User("John"); // 将调用重定向到新用户
        // console.log(john); // John
        // console.log(john.name); // John
        // 6 构造器的 return
        // function BigUser() {
        //   this.name = "John";
        //   return { name: "Godzilla" };  // <-- 返回这个对象
        // }
        // console.log( new BigUser().name );  // Godzilla，得到了那个对象
        // function SmallUser() {
        //   this.name = "John";
        //   return; // <-- 返回 this
        // }
        // console.log( new SmallUser().name );  // John
        // // 省略括号 顺便说一下，如果没有参数，我们可以省略 new 后的括号：
        // // 这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法
        // let user = new User; // <-- 没有参数
        // // 等同于
        // let user = new User();
        // 7 构造器中的方法
        // function User(name) {
        //   this.name = name;

        //   this.sayHi = function() {
        //     console.log( "My name is: " + this.name );
        //   };
        // }

        // let john = new User("John");

        // john.sayHi(); // My name is: John
        // console.log(john); // User {name: "John", sayHi: ƒ}
        // 等同于
        // john = {
        //   name: "John",
        //   sayHi: function() {  }
        // }
        

    </script>
</body>
</html>