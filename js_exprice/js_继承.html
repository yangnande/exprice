<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>https://juejin.im/post/5e75e22951882549027687f9?utm_source=gold_browser_extension#heading-6</title>
</head>
<body>
  <script>
    // 继承：子类可以继承父类的所有功能，并且对这些功能进行扩展
    // 1原型链继承-将子类的原型对象指向父类的实例
    // 1.1
    // child1是通过子类构造函数Child生成的对象，那我就有属性name，并且属性值也是自己的child
    // 然后子类构造函数Child它的原型被指向了父类构造函数Parent创建出来的"无名实例"
    // 这样的话，我child1就可以使用你这个"无名实例"里的所有属性和方法了呀，因此child1.getName()有效。并且打印出child。
    // 另外由于sex、getName都是Child原型对象上的属性，所以并不会表现在child1上。
    // function Parent() {
    //     this.name = 'Parent'
    //     this.sex = 'boy'
    // }
    // Parent.prototype.getName = function () {
    //     console.log(this.name)
    // }
    // function Child() {
    //     this.name = 'child'
    // }
    // Child.prototype = new Parent() // 将子类的原型对象指向父类的实例
    // console.log(new Parent()); // Parent{name:'Parent',sex: 'boy'}
    // var child1 = new Child()
    // child1.getName() // child
    // console.log(child1) // Child{name:'child'}
    // 1.2 错误的做法啊 为了说明一下，为什么原型链继承是要用Child.prototype = new Parent()这种方式
    // function Parent() {
    //   this.name = 'Parent'
    //   this.sex = 'boy'
    // }
    // Parent.prototype.getSex = function () {
    //     console.log(this.sex)
    // }
    // function Child() {
    //     this.name = 'child'
    // }
    // Child.prototype = Parent.prototype // 将子类的原型对象指向父类的原型对象
    // var child1 = new Child()
    // child1.getSex() // undefined
    // console.log(child1) // Child{name:'child'}
    // 1.3
    // function Parent (name) {
    //   this.name = name
    //   this.sex = 'boy'
    //   this.colors = ['white', 'black']
    // }
    // function Child () {
    //   this.feature = ['cute']
    // }
    // var parent = new Parent('parent')
    // Child.prototype = parent

    // var child1 = new Child('child1')
    // child1.sex = 'girl' // 给Child的实例对象创建自身属性sex 
    // child1.colors.push('yellow') // 执行push操作，所以这时候改变的是原型对象parent上的属性，会影响到后续所有的实例对象 凭什么sex就是在实例对象child上新增，而我colors不行，那是因为操作的方式不同，sex那里是我不管你有没有，反正我就直接用=来覆盖你了，可是push它的前提是我得先有colors且类型是数组才行，不然你换成没有的属性，比如一个名为clothes的属性，child1.clothes.push('jacket')它直接就报错了，如果你使用的是child1.colors = ['yellow']这样才不会影响parent)
    // child1.feature.push('sunshine') // feature它是属于child1实例自身的属性，它添加还是减少都不会影响到其他实例。

    // var child2 = new Child('child2')

    // console.log(child1) // Child{feature:['cute','sunshine'],sex :'girl'}
    // console.log(child2)  // Child{feature:['cute']}

    // console.log(child1.name) // parent 原型对象parent上的name，也就是'parent'，虽然我们在new Child的时候传递了'child1'，但它显然是无效的，因为接收name属性的是构造函数Parent，而不是Child。
    // console.log(child2.colors) // ['white', 'black','yellow']

    // console.log(parent) // Child{name:'parent',sex:'boy',colors:['white', 'black','yellow']}
    // 总结原型链的优点和缺点
    // 优点：
    // 继承了父类的模板，又继承了父类的原型对象
    // 缺点：
    // 如果要给子类的原型上新增属性和方法，就必须放在Child.prototype = new Parent()这样的语句后面
    // 无法实现多继承(因为已经指定了原型对象了)
    // 来自原型对象的所有属性都被共享了，这样如果不小心修改了原型对象中的引用类型属性，那么所有子类创建的实例对象都会受到影响(这点从修改child1.colors可以看出来)
    // 创建子类时，无法向父类构造函数传参数(这点从child1.name可以看出来)

    // 2 instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
    // 再来看看通俗点的简介：
    // a instanceof B //  构造函数B的原型对象属性 是否出现在实例对象a的原型链上
    // 实例对象a instanceof 构造函数B
    // 检测a的原型链(__proto__)上是否有B.prototype，有则返回true，否则返回false。
    // 2.1
    // function Parent () {
    //   this.name = 'parent'
    // }
    // function Child () {
    //   this.sex = 'boy'
    // }
    // Child.prototype = new Parent()
    // var child1 = new Child()

    // console.log(child1 instanceof Child) // true
    // console.log(child1 instanceof Parent) // true
    // console.log(child1 instanceof Object) // true
    // child1 instanceof Parent的查找顺序：
    // child1 -> child1.__proto__ -> Child.prototype -> Child.prototype.__proto__ -> Parent.prototype
    // 2.2 isPrototypeOf 它属于Object.prototype上的方法 用来判断指定对象object1是否存在于另一个对象object2的原型链中，是则返回true，否则返回false
    // function Parent () {
    //   this.name = 'parent'
    // }
    // function Child () {
    //   this.sex = 'boy'
    // }
    // Child.prototype = new Parent()
    // var child1 = new Child()

    // console.log(Child.prototype.isPrototypeOf(child1)) // true
    // console.log(Parent.prototype.isPrototypeOf(child1)) // true
    // console.log(Object.prototype.isPrototypeOf(child1)) // true
    // function Parent (name) {
    //   this.name = name
    // }
    // Parent.prototype.getName = function () {
    //   console.log(this.name)
    // }
    // function Child (name) {
    //   this.sex = 'boy'
    //   Parent.call(this,name)
    // }
    // Child.prototype = new Parent ()
    // Child.prototype.getSex = function () {
    //   console.log(this.sex)
    // }
    // var child1 = new Child('child1')
    // var parent1 = new Parent('parent1')
    // console.log(child1) // Child{ name: 'child1', sex: 'boy' }
    // console.log(parent1)// Parent{ name: 'parent1' }
    // child1.getName()    // 'child1'
    // child1.getSex()     // 'boy'
    // parent1.getName()   // 'parent1'
    // parent1.getSex()    // Uncaught TypeError: parent1.getSex is not a function
  </script>
</body>
</html>