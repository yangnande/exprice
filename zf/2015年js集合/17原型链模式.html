<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16和17是视频反的，笔记也是反的 16是17的笔记，17是16的笔记</title>
</head>
<body>
    <script>
        // 在原型模式中，this常用的有两种情况：
        // 在类中this.xxx = xxx，this->当前类的实例
        // 某一个方法中this->看执行的时候'.'前面是谁this就是谁
        // 1)需要先确定this的指向（this是谁）
        // 2)把this替换成对应的代码
        // 3)按照原型链查找的机制，一步步的查找结果
        // function Fn() {
        //     this.x = 100
        //     this.y = 200
        //     this.getY = function() {
        //         console.log(this.y);
        //     }
        // }
        // Fn.prototype = {
        //     constructor: Fn,
        //     y: 300,
        //     getX: function() {
        //         console.log(this.x);
        //     },
        //     getY: function() {
        //         console.log(this.y);
        //     }
        // }
        // var f = new Fn;
        // f.getX() // f.x = 100
        // f.__proto__.getX() // f.__proto__.x = undefined
        // Fn.prototype.getX() // f.prototype.x = undefined
        // f.getY() // f.y = 200
        // f.__proto__.getY() // f.__proto__.y = 300
        // Array.prototype.myUnique = function() {
        //     // this->ary
        //     var obj = {}
        //     for(var i = 0;i<this.length;i++) {
        //         var cur = this[i]
        //         if(obj[cur] == cur) {
        //             this[i] = this[this.length-1]
        //             this.length--;
        //             i--;
        //             continue;
        //         }
        //         obj[cur] = cur
        //     }
        //     console.log(obj);
        //     obj = null
        //     return this // 目的是为了实现链式写法
        // }
        var ary = [12,23,23,13,12,13,23,13,12]
        // ary.myUnique() // this==ary
        // Array.prototype.myUnique().sort(function(a,b){
        //     return a - b
        // }) // this==Array.prototype
        // console.log(ary);
        // 链式写法：执行完成数组的一个方法可以紧接着执行下一个方法
        // 原理：
        // ary为什么可以使用sort方法？因为sort是Array.prototype上的公有的方法，而数组ary是Array这个类的一个实例，所以ary可以使用sort方法->数组才能使用我们Array原型上定义的属性和方法。
        // sort执行完成的返回值是一个排序后的"数组"，可以继续执行pop
        // reverse执行完成的返回值是一个数组，可以继续执行pop
        // pop执行执行完成的返回值是被删除的那个元素，不是一个数组了,所以在执行push报错
        // ary.sort(function(a,b){
        //     return a - b
        // }).reverse().pop().push('zf')
        // console.log(ary); //Uncaught TypeError:ary.sort(...).reverse(...).pop(...).push is not a function
        // 在数组的原型上有一个方法叫做slice,我们要求大家自己回去自己实现一个方法mySlice，要求和原来slice功能一摸一样
        Array.prototype.mySlice = function() {}
        // 要考虑的情况
        slice(n,m)
        slice(n)
        slice()
        // n m是负数
        // n<m是什么情况
        // n和m的值超过数组的长度了
        // n和m不是有效数字
        // 要求：不能使用数据内置的方法，比如添加不能使用push，而使用ary[ary.length-1]=xxx
        // 2实现一个需求
        // (5).plus(10).reduce(2) 5+10-2
        Array.prototype.plus = function(num) {}
        Array.prototype.reduce = function(num) {}
    </script>
</body>
</html>