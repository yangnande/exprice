<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        "use strict" //->告诉当前浏览器接下来的JS代码将按照严格模式进行编写
        var obj = {name: "珠峰培训"}
        function fn (num1,num2) {
            console.log (num1 + num2) 
            console.log (this) 
        }
        // fn(100, 200) //300 非严格模式下this->window 严格模式下this->undefined num1=100 num2=200 
        // fn.call(100,200)  //NaN this->100 num1=200 num2=undefined
        // fn.call(obj, 100, 200)  // 300 this->obj num1=100 num2=200
        // fn.call()  //NaN 非严格模式下this->window 在严格模式 下this->undefined
        // fn.call(null)  //NaN 非严格模式下this->window 在严格模式下this->null
        // fn.call(undefined) //NaN 非严格模式下 this->window在严格模式下this->undefined
        // //apply和ca11方法的作用是一模一样的， 都是用来改变方法的this关键字并且把方法执行而且在严格模式下和非严格模式下对于第一个参数是null/undefined这种情况的规律也是一样的 
        // fn.call (obj, 100, 200) 
        // fn.apply(abj, [100,200])//->ca11在给fn传递参数的时候，是一个一个传递值的，而apply不是一个个传，而是把要给fn传递的参数值统一的放在一个数组中进行操作->但是也相当于一个个的给fn的形参赋值

        //bind:这个方法在IE6~8下不兼容-> 和call/apply类似都是用来改变this关键字的
        //fn.call(obj, 1，2) //->改变this和执行fn函数是一起都完成了
        //-> 预处理:事先把fn的this改变为我们想要的结果,并且把对应的参数值也准备好,以后要用到了,直接的执行即可
        // var tempEn = fn.bind(obj, 1, 2) //->只是改变了fn中的this为obj,并且给fn传递了两个参数值1、2, 但是此时并没有把fn这个函数执行;执行bind会有一个返回值,这个返回值tempFn就是我们把fn的this改变后的那个结果
        // console.log(tempEn);
        // tempEn() 
    </script>
</body>
</html>