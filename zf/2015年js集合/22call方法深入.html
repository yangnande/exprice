<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        Array .prototype.slice=function () {}
        var ary = [12, 23, 34]
        //ary.slice ->ary这个实例通过原型链的查找机制找到Array .prototype.上的s1ice方法
        // ary.slice() ->让找到的slice方法执行,在执行slice方法的过程中,才把ary数组进行I藏取
        //Function.prototype.call = function(){}
        var obji = {name: "珠峰培训"} ;
        function fn () {
            console.log(this);
        }
        fn()
        fn.myCall(obj); //->myCal1方法中的this是fn|
        sum.myCall(obj); //->myCa11方法中的this是sum
        function sum() {}
        //obj.fn() ://->Uncaught TypeError: obj. fn is not a function
        //ca11方法的作用:
        //->首先我们让原型上的call方法执行,在执行ca11方法的时候,我们让fn方法中的this变为第一个参数值obj;然后再把fn这个函数执行;
        // fn.call(obj)
        //自己模拟内置的ca11方法,写一个myCall方法,深入探讨ca11方法的执行原理
        Function.prototype.myCall = function (context) {
            //- >myCa11方法中的this就是当前我要操作和改变其this关键字的那个函数名
            //->1.让fn 中的this关键字变为context的值- >obj
            //->让this这个函数中的"this关键字"变为context
            //eval(this.tostring().replace ("this", "obj")) ;
            //->2.让fn方法在执行
            this() ;
        }
        function fn1 () {console.log(1)}
        function fn2() {console.log(2) }
        fn1.call(fn2) ;//->首先fn1通过原型链机制找到Function. prototype上的call方法,并且让call方法执行->此时call这个方法中的this就是我要操作的fn1->在call方法代码执行的过程中首先让fn1中的"this关键字"变为fn2,然后在让fn1这个方法执行->1 .
        fn1.call.call(fn2) ;//->fn1.ca11 首先fn1通过原型链找到Function.prototype上的call方法 ,然后在让call方法通过原型在找到Function原型上的call(因为ca11本身的值也是一个函数,所以同样可以找到Function.prototype)在第二次在找到call的时候让方法执行,方法中的this是fn1.call,首先让这个方法中的this变为fn2,然后再让fn1.call执行->2
        function zhufeng (context) {
            //->1、-> 让this这个函数中的"this关键字”变为context
            //->2、-> 让this方法在执行
            this () ;
        }
        Function.prototype.myCal1 = zhufeng;
        fn1.call.call(fn2)
       //->fn1.call -> zhufeng ;
       //->zhufeng.ca11(fn2) -> 先让ca11方法执行，call中的this是zhufeng,让zhufeng中的this变为fn2,在让zhufeng执行->2
       fn1.cal1.cal1.ca11.cal1.ca11 (fn2);
       Function.prototype.call (fn1);
       Function.prototype.call.cal1.call(fn1);
    </script>
</body>
</html>