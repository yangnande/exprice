<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div></div>
  <div></div>
  <script>
    // var oLis = document.getElementsByTagName("div") ;
    // console.dir(oLis); //->HTMLCollection元素集合类的一个实例->它也是一个类数组集合
    // oLis = document.getElementsByName("zhufeng");
    // console.dir(oLis); //->NodeLis节点集合->它也是一个类数组集合
    var oLis = document.getElementsByTagName("div") ;
    var ary = Array.prototype.slice.call(oLis) ;
    console.log(ary) ;
    // ->在IE6~8浏览器中,不支持元素集合的数组的slice实现将元素集合的类数组转换为数组
    //->非标准
    for (var i = o; i < oLis.length; i++){
      ary[ary.length] =oLis[i];
    }
    //->在IE6~8浏览器中,不支持借用数组的slice实现将元素集合(节点集合)的类数组转换为数组->SCRIPT5014: Array.prototype.slice: 'this'不是javascript对象报错
    // ->但是对于arguments借用数组的方法是不存在任何兼容性问题的
    // try catch  
    // 我们在Js中使用try、catch进行浏览器的异常信息捕获
    // console.log(num) ; //->Uncaught ReferenceError: num is not defined在Js中本行报错,下面代码都不在执行了
    // consoie.iog("ok");
    // try {
    //   console.log(num)
    // } catch (e) {// 形参必须要写，我们一般起名为e
    //   console.log(e.message); // num is not defined 可以收集当前代码报错的原因
    // }
    // consoie.iog("ok");
    // try {
    //   // <js code>
    // } catch (e) {
    //   // 如果代码报错执行catch中的代码
    // } finally {
    //   // 一般不用，不管try中的代码是否报错，都要执行finally中的代码
    // }
    // 有时候既想捕获错误的信息，又不想让下面的代码继续执行
    // try {
    //   console.log(num)
    // } catch (e) {/
    //   console.log(e.message); // 可以得到错误的信息，把其进行统计
      // ->手动抛出一条错误信息,终止代码执行
        throw new Error("当前网络繁忙,请稍后在试~~" ) ;
        // new ReferenceError ->引用错误
        // new TypeError ->类型错误
        // new RangeError ->范围错误
    // }
    // consoie.iog("ok");
  </script>
</body>
</html>