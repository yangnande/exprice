<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>
  <button>你点我呀</button>
  <div id="div1" class="div1">
    <p id="p1" data-name="p1" class="p">我是p1</p>
    <p id="p2" class="p">我是p2</p>
  </div>
  <div id="div2">
    <p id="p3" data-name="p1">我是p3</p>
    <p id="p4">我是p4</p>
  </div>
  <script src="../public/js/jquery-1.12.1.min.js"></script>
  <script>
    // 变量的类型和计算 1 值类型（数字，字符串，布尔，undefined，null）和引用类型（对象，数组，函数）
    // 区别：从存储空间来讲，值类型存储是一个变量一个值，而引用类型是变量的值是一个指针，通过指针指向值
    // 1.1 值类型 
    // var a = 100
    // b = a 
    // a = 200
    // console.log(b,'值类型') // b为100
    // 1.2 引用类型
    // var info1 = {age: 20}
    // var info2 = info1
    // info2.age = 21
    // console.log(info1.age, '引用类型') // info1.age为21
    // 1.3 typeof 只能区分值类型
    // console.log(typeof undefined) // 'undefined'
    // console.log(typeof 11)  // 'number'
    // console.log(typeof '你好') // 'string'
    // console.log(typeof true) // 'boolean'
    // console.log(typeof []) // 'object'
    // console.log(typeof {}) // 'object'
    // console.log(typeof null) // 'object'
    // console.log(typeof function() {}) // 'function'
  // 2 变量计算-强制类型的转换
  // 2.1 字符串拼接
  // console.log(100 + 10)  // '110'
  // console.log(100 + '10') // '10010'
  // 2.2 == 
  // console.log(0 == '') // false
  // console.log(100 == '100')  // false
  // console.log(null == undefined)  // false
  // 什么时候用两个等号，什么时候用三个等号
  // var obj = {}
  // if(obj.a == null){
    // jquery源码推荐的写法
    // 这里相当于obj.a === null||obj.a === undefined的简写形式 ，其他的比较都用三等号
  // }
  // 2.3 if NaN,'',0,null,undefined,false 都是false
  // var val1 = true
  // if (val1) {
    // 会执行
  // }
  // var val2 = 100
  // if (val2) {
    // 100会转换成true会执行
  // }
  // var val3 = ''
  // if (val3) {
    // ''会转换成false不会执行
  // }
  // 2.4 逻辑运算符
  // console.log(0&&9) // 0 第一个是false,返回第一个值，否则不管第二个值返回true或false就返回第二个值
  // console.log('abc'||'') // 'abc' 第一个是true,返回第一个值，否则不管第二个值返回true或false就返回第二个值
  // console.log(!window.abc) // true
  // var aaa = 100
  // console.log(!!100) // true
  // 2.5js有哪些内置函数 Number,String,Boolean,Array,Object,Function,Date,RegExp,Error
  // 2.6 如何理解json 是一个js对象，还是一个数据格式
  // 2.6.1 常用的两个方法
  // console.log(JSON.stringify({a:10,b:20})) // js对象转换成json字符串
  // console.log(JSON.parse('{"a":10,"b":20}'))// json字符串转换成js对象
  // 3如何准备判断一个变量是一个数组
  // var arr1 = []
  // console.log(arr1 instanceof Array) // true 正确
  // console.log(typeof arr1) // object错误
  // 4 写一个原型链继承的例子
  // function Animal() {
  //   this.eat = function () {
  //     console.log('animal eat')
  //   }
  // }
  // function Dog () {
  //   this.bark = function () {
  //     console.log('dog bark')
  //   }
  // }
  // Dog.prototype = new Animal()
  // var hashiqi = new Dog()
  // hashiqi.bark()
  // hashiqi.eat()
  // 5 描述new一个对象的过程 
  // a创建了一个新对象bthis指向这个新对象c执行代码即对this赋值d返回this
  // 6 zepto（或其他框架）源码中如何使用原型链
  // a阅读源码是高效提高技能的方式b但不能埋头苦钻，有技巧在其中c慕课网搜索zepto设计和源码分析
  // 7 构造函数 特点：1函数名第一个字母大写2使用时用new
  // function Foo(name,age) {
  //   this.name = name
  //   this.age = age
  //   this.class = 'class-1'
    // return this // 默认有这一行
  // } 
  // var f = new Foo('tom',12)
  // var f1 = new Foo('jerry',13) // 创建多个对象
  // console.log(f,f1)
  // 8 构造函数-扩展
  // var a = {} // 其实是var a = new Object()的语法糖
  // var a = [] // 其实是var a = new Array()的语法糖
  // function Foo() {} // 其实是var Foo = new Function()的语法糖
  // 使用instanceOf判断一个函数是否是一个变量的构造函数
  // 5条原型规则 原型规则是学习原型链的基础
  // 原型规则1，所有的引用类型（函数，数组，对象），都具有对象的属性，即可自由扩展属性
  // 原型规则2，所有的引用类型（函数，数组，对象），都有一个__proto__（隐性类型）属性，属性值是一个普通的对象
  // 原型规则3，所有的函数，都有一个prototype(显性类型)属性，属性值也是一个普通的对象
  // 原型规则4，所有的引用类型（函数，数组，对象），__proto__（隐性类型）属性的值指向它的构造函数的prototype(显性类型)属性值
  // 原型规则5，当试图得到一个对象的某个属性值时，如果这个对象本身没有这个属性，那么会去它的__proto__(即它的构造函数的prototype)中寻找
  
  // var obj = {};obj.a = 100
  // var arr = {};arr.a = 100
  // function fn () {};fn.a = 100;

  // console.log(obj.__proto__)
  // console.log(arr.__proto__)
  // console.log(fn.__proto__)

  // console.log(fn.prototype)

  // console.log(obj.__proto__ === Object.prototype)
  // function Foo1 (name) {
  //   this.name = name
  // }
  // Foo1.prototype.sayHi = function () {
  //   console.log(this.name,'say hi')
  // }
  // var f2 = new Foo1('zhangsan')
  // f2.sayHello = function () {
  //   console.log(this.name,'say hello')
  // }
  // f2.sayHi()
  // f2.sayHello()
  // 总结不管是f2在调用属性时，不管Foo1函数的显性原型还是f2自身函数的this 都指向f2
  // 循环对象自身的属性
  // for(var item in f2) {
    // for in 高级浏览器已经屏蔽了来自原型的属性
    // 为了保证代码的健壮性，要加一层判断
  //   if (f2.hasOwnProperty(item)) {
  //     console.log(item)
  //   }
  // }
  // console.log(f2.toString()) // 从f2.__proto__.__proto__去找 f2.__proto__===Foo1.prototype f2.__proto__.__proto__===Object.prototype
  // 总结 f2 instanceof Foo1 意思是f2是通过Foo1 new出来的实例,通过f2.__proto__一层一层往上找，可以对应到Foo1.prototype,此判断正确
  // 总结 f2 instanceof Object 通过f2.__proto__一层一层往上找，可以对应到Object.prototype,此判断正确
  // 9全局中和函数内部的变量提升，函数声明提前，不会报错，会打印出来undefined
  // console.log(a2)
  // var a2 = 100
  // fun ('99')
  // function fun (parms) {
  //   // this,arguments是函数执行时就有的
  //   console.log(this)
  //   console.log(arguments)
  //   console.log(parms)
  //   console.log(a3)
  //   var a3 = 100
  //   fun1 ()
  //   function fun1 () {
  //     console.log('fun1')
  //   }
  // }
  // fn2() // 函数表达式提前调用就会报错 fn2 is not a function
  // var fn2 = function () {
  //   console.log('fn2')
  // }
  // 10 说一下对变量提升的理解-变量的定义和函数的声明
  // 11 说明this几种不同的场景-1作为构造函数2作为普通函数3作为对象4call,bind,apply
  // 12 创建10个<a>标签，点击的时候弹出对应的序号
  // 错误的写法
  // var i,a;
  // for(i = 0;i<10;i++) {
  //   a = document.createElement('a');
  //   a.innerHTML = i + '<br/>'
  //   a.addEventListener('click', function(e) {
  //     e.preventDefault()
  //     alert(i) // 每个都是10
  //   })
  //   document.body.appendChild(a)
  // }
  
  // 正确的写法
  // var i,a;
  // for(i = 0;i<10;i++) {
  //   (function(i) {
  //     a = document.createElement('a');
  //     a.innerHTML = i + '<br/>'
  //     a.addEventListener('click', function(e) {
  //       e.preventDefault()
  //       alert(i) // 每个都是10
  //     })
  //     document.body.appendChild(a)
  //   }) (i)
  // }
  // 13 如何理解作用域 a自由变量b作用域链即自由变量的查找c闭包的两个场景
  // 14 实际开发中闭包的作用
  // 执行上下文 a范围：一段<script>或者一个函数 b全局：变量定义，函数声明 c函数：变量定义、函数声明、this/arguments
  // 15 this要在执行时才能确认值，定义时无法确认
  // 15.1对象中的this
  // var obj = {
  //   name: 'zhangsan',
  //   fn: function () {
  //     console.log(this)
  //   }
  // }
  // obj.fn() // this指向obj
  // obj.fn.call({name:'lisi'}) // this指向{name:'lisi'}
  // var fn1 = obj.fn
  // fn1() // this指向window
  // 15.2构造函数中的this
  // function Foo(name) {
    // console.log(this) // {}
    // this.name = name
    // console.log(this) // {name: '张三'}
  // }
  // var foo1 = new Foo('张三')
  // 15.3 函数中的this
  // function fn() {
  //   console.log(this) // window
  // }
  // fn()
  // 15.4 call bind apply
  // function fun2(name) {
  //   console.log(this)
  // }
  // fun2('lele')
  // fun2.call({name:'call'},'call')
  // 只有函数表达式才能用bind
  // var fun3 = function () {
  //   console.log(this)
  // }.bind({name:'bind'})
  // fun3('bind')
  // 16 作用域 a没有块级作用域b只有全局作用域和函数作用域
  // 16.1无块级作用域
  // if(true) {
  //   var name = 'lele'
  // }
  // console.log(name, '无块级作用域')
  // 16.2无块级作用域
  // var a = 100
  // function fn4 () {
  //   var a = 200
  //   console.log(a, '函数作用域')
  // }
  // console.log(a, '全局作用域')
  // fn4()
  // 17 作用域链 在定义的时候值已经确定 跟执行时的作用域无关
  // var a = 100
  // function fun5 () {
  //   var b = 200
  //   // 当前作用域没有定义的变量，即为'自由变量'
  //   console.log(a)
  //   console.log(b)
  // }
  // fun5()
  // var a = 100
  // function fun6 () {
  //   var b = 200
  //   function fun7 () {
  //     var c = 300
  //     // 当前作用域没有定义的变量，即为'自由变量'
  //     console.log(a)
  //     console.log(b)
  //     console.log(c)
  //   }
  //   fun7()
  // }
  // fun6()
  // 18闭包
  // function fn5 () {
  //   var a = 100
  //   return function () {
  //     // 自由变量，会像父级去寻找
  //     console.log(a)
  //   }
  // }
  // // f3 得到一个函数
  // var f3 = fn5()
  // var a = 200
  // f3() // 100
  // 18.1闭包的使用场景
  // 18.1.1 函数作为一个返回值，如第一个例子
  // 18.1.2 函数作为参数传递
  // function fn5 () {
  //   var a = 100
  //   return function () {
  //     // 自由变量，会像父级去寻找
  //     console.log(a)
  //   }
  // }
  // f3 得到一个函数
  // var f3 = fn5()
  // function fn6 (fn) {
  //   var a = 200
  //   fn()
  // }
  // fn6(f3)
  // 18.1.3闭包在实际生活的应用-数组中有没有重复的值
  // function isFirstLoad () {
  //   var _list = []
  //   return function (id) {
  //     if (_list.indexOf(id)>=0) {
  //       return false
  //     } else {
  //       _list.push(id)
  //       return true
  //     }
  //   }
  // }
  // var firstLoad = isFirstLoad()
  // console.log(firstLoad(100)) // true
  // console.log(firstLoad(100)) // false
  // console.log(firstLoad(200)) // true
  // console.log(firstLoad(200)) // false
  // 19同步和异步
  // 19.1同步和异步的区别，分别举一个同步和异步的例子
  // 同步会阻塞代码，而异步不会 alert是同步 setTimeout是异步
  // 19.1.1什么是异步
  // console.log(100)
  // setTimeout(function() {
  //   console.log(200)
  // },1000)
  // console.log(300)
  // 19.1.2 对比同步 一个执行完才能执行另一个 alert阻塞了后边的执行
  // console.log(100)
  // alert(200)
  // console.log(300)
  // 打印结果100,300,200
  // 19.1.3何时需要异步 a在可能发生等待的情况b等待过程中不能出现像alert一样阻塞程序的运行c因此"所有的情况"都需要异步
  // 19.1.4前端使用异步的情景
  // a定时任务：setTimeout,setInterval b、ajax请求，动态img加载c事件绑定
  // 19.2一个关于setTimeout的例子
  // 19.3前端使用的异步场景有哪些
  // console.log('start')
  // $.get("./json/data.json",function(data) {
  //   console.log(data)
  // })
  // var img = document.createElement('img')
  // img.onload = function() {
  //   console.log('load')
  // }
  // img.src="./img/1.jpg"
  // document.getElementsByTagName('button')[0].addEventListener('click', function() {
  //   alert(666)
  // })
  // console.log('end') 
  // 打印结果start,end,data
  // 20 单线程 特点：只能干一件事，不能同时干两件事
  // console.log(100)
  // setTimeout(function() {
  //   console.log(200)
  // },1000)
  // console.log(300)
  // 1执行354行代码，打印出100
  // 2执行355行代码，发现是异步，会把setTimeout里的函数暂存起来
  // 3执行357行代码，打印出300
  // 4待同步的执行完毕，空闲时会检查暂存区有么有要执行的代码
  // 5发现暂存的代码，无需时间，所以立即执行
  // 21获取2017-06-10格式的日期
    // function formDate (date) {
    //   if(!date) {
    //     date = new Date()
    //   }
    //   var year = date.getFullYear()
    //   var month = date.getMonth() + 1
    //   var day = date.getDate()
    //   var hours = date.getHours()
    //   var minute = date.getMinutes()
    //   var seconds = date.getSeconds()
    //   if (month < 10) {
    //     month = '0' + month
    //   }
    //   if (day < 10) {
    //     day = '0' + day
    //   }
    //   if (hours < 10) {
    //     hours = '0' + hours
    //   }
    //   if (minute < 10) {
    //     minute = '0' + minute
    //   }
    //   if (seconds < 10) {
    //     seconds = '0' + seconds
    //   }
    //   console.log(year + '-' + month + '-' + day + ' ' + hours + ':' + minute + ':' + seconds)
    //   return year + '-' + month + '-' + day + '-' + hours + ':' + minute + ':' + seconds
    // }
    // formDate(new Date())
  // 21.1日期的api
  // console.log(Date.now())
  // var date = new Date() // 当前日期
  // var ms = date.getTime() // 当前毫秒数
  // var year = date.getFullYear() // 年(0-11)
  // var month = date.getMonth() // 月
  // var dates = date.getDate() // 日
  // var hours = date.getHours() // 时
  // var minutes = date.getMinutes() // 分
  // var seconds = date.getSeconds() // 秒
  // var week = date.getDay() // 秒
  // console.log(date,ms,year,month,dates,hours,minutes,seconds,week)
  // 22获取随机数，要求长度一致的字符串
  // var randoms = Math.random() + '0000000000' // 为了代码的健壮性，补10个0
  //     randoms = randoms.substr(0,10)
  // console.log(randoms)
  // 23写一个能遍历数组和对象的通用的forEach函数
  // function forEach (obj,fn) {
  //   if(obj instanceof Array) {
  //     obj.forEach(function (item,index) {
  //       fn(index,item)
  //     })
  //   } else {
  //     for(var key in obj) {
  //       fn(key, obj[key])
  //     }
  //   }
  // }
  // var arr = [1,5,2,3,4]
  // forEach(arr,function fn (index,item) {
  //   console.log(index,item, 'arr')
  // })
  // var obj = {
  //   'a': 1,
  //   'b': 2,
  //   'c': 3,
  // }
  // forEach(obj,function fn (index,item) {
  //   console.log(index,item, 'obj')
  // })
  // 23.1 forEach 无返回值 不改变原数组
  // var arr = [1,5,2,3,4]
  // var arr1 = arr.forEach(function(item,index) {
  //   arr[index]*2
  //   console.log(item,index)// item为值，index为val
  // })
  // 23.2 every 全部符合条件返回true
  // var arr1 = arr.every(function(item,index) {
  //   if (item>3) {
  //     return true
  //   }
  //   console.log(item,index)// item为值，index为val
  // })
  // 23.3 some 一个符合条件返回true
  // var arr1 = arr.some(function(item,index) {
  //   if (item>3) {
  //     return true
  //   }
  //   console.log(item,index)// item为值，index为val
  // })
  // 23.3 some 一个符合条件返回true
  // var arr1 = arr.some(function(item,index) {
  //   if (item>3) {
  //     return true
  //   }
  //   console.log(item,index)// item为值，index为val
  // })
  // 23.4 sort 排序 改变原数组
  // var arr1 = arr.sort(function(a,b) {
  //   return b-a // 从大到小
  //   // return a-b // 从小到大
  // })
  // console.log(arr1,arr) // true [1,2,3,4]
  // 23.5 filter 新数组，过滤出符合元素数组 不改变原数组
  // var arr1 = arr.filter(function(v,i) {
  //   return v>2
  // })
  // console.log(arr1,arr) // true [1,2,3,4]
  // 24 对象的api
  // var obj = {
  //   a: 100,
  //   b: 200,
  //   c: 300
  // }
  // 24.1for in
  // for(var key in obj) {
  //   // 判断是自己本身的属性，而不是原型链上的属性
  //   if(obj.hasOwnProperty(key)) {
  //     console.log(key,obj[key])
  //   }
  // }
  // 25 常说的js分为两个部分：aJS基础知识（ ECMA262标准）bJS-Web-API(W3C标准)
  // 26DOM:浏览器把拿到的html代码，结构化一个浏览器能识别并且js可操作的一个模型而已
  // 26.1 获取DOM节点
  
  // var div1 = document.getElementById('div1')
  // console.log(div1,'div1')
  // var divList = document.getElementsByTagName('div')
  // console.log(divList,'divList')
  // var pList = document.querySelectorAll('p')
  // console.log(pList,'pList')
  // pClasses = document.getElementsByClassName('p')
  // console.log(pClasses,'pClasses')
  // 26.2 prototype(js的标准属性) attribute（html元素上的属性）
  // prototype(js的标准属性)
  // console.log(div1.className,'div.className1')
  // div1.className = 'aaa'
  // console.log(div1.className,'div.className2')
  // attribute（html元素上的属性）
  // var p1 = document.getElementById('p1')
  // console.log(p1.getAttribute('data-name'))
  // p1.setAttribute('data-name','6666')
  // console.log(p1.getAttribute('data-name'))
  // 27新增节点
  // var p5 = document.createElement('p')
  // p5.innerHTML = 'new p'
  // var div1 = document.getElementById('div1')
  // div1.appendChild(p5)
  // 27节点改变位置
  // var div2 = document.getElementById('div2')
  // var p1 = document.getElementById('p1')
  // div2.appendChild(p1)
  // 28查找父节点/子节点
  // var p1 = document.getElementById('p1')
  // var div2 = document.getElementById('div2')
  // console.log(p1.parentElement)
  // console.log(div2.parentElement)
  // console.log(div2.childNodes) // 5个 3个text 1个p1 1个p2
  // 29移除子节点
//  var child = div2.childNodes
//  console.log(div2.childNodes[0].nodeType) // text 3
//  console.log(div2.childNodes[1].nodeType) // div 1
//  console.log(div2.childNodes[0].nodeName) // text #text
//  console.log(div2.childNodes[1].nodeName) // div p
//  div2.removeChild(child[1])
  </script>
</body>
</html>